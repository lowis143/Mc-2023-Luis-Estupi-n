# -*- coding: utf-8 -*-
"""taller #25

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FqC8MW-qhyEivbzCGLK6Ax5QCCp81MOh
"""

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
 
class BinarySearchTree:
    def __init__(self):
        self.root = None
 
    def insert(self, value):
        new_node = Node(value)
        if self.root is None:
            self.root = new_node
            return
        current = self.root
        while True:
            if value < current.value:
                if current.left is None:
                    current.left = new_node
                    break
                else:
                    current = current.left
            elif value > current.value:
                if current.right is None:
                    current.right = new_node
                    break
                else:
                    current = current.right
            else:
                break
 
    def inorder_traversal(self, node):
        if node is None:
            return
        self.inorder_traversal(node.left)
        print(node.value, end=' ')
        self.inorder_traversal(node.right)
 
 
A = [21,14,2,11,7,20,13,30,18,5,6,29,12,27,4,28,10,15,22,1,19,3]
bst = BinarySearchTree()
for num in A:
    bst.insert(num)
 
bst.inorder_traversal(bst.root)

class BTreeNode:
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.child = []


class BTree:
    def __init__(self, m):
        self.root = BTreeNode(True)
        self.m = m

    def insert(self, value):
        node = self.root
        if len(node.keys) == 2 * self.m - 1:
            new_node = BTreeNode()
            self.root = new_node
            new_node.child.append(node)
            self._split(new_node, 0)
            self._insert_non_full(new_node, value)
        else:
            self._insert_non_full(node, value)

    def _insert_non_full(self, node, value):
        i = len(node.keys) - 1
        if node.leaf:
            node.keys.append(None)
            while i >= 0 and value < node.keys[i]:
                node.keys[i+1] = node.keys[i]
                i -= 1
            node.keys[i+1] = value
        else:
            while i >= 0 and value < node.keys[i]:
                i -= 1
            i += 1
            if len(node.child[i].keys) == 2 * self.m - 1:
                self._split(node, i)
                if value > node.keys[i]:
                    i += 1
            self._insert_non_full(node.child[i], value)

    def _split(self, node, i):
        t = self.m
        new_node = BTreeNode(node.child[i].leaf)
        node.child.insert(i+1, new_node)
        node.keys.insert(i, node.child[i].keys[t-1])
        new_node.keys = node.child[i].keys[t:(2*t-1)]
        node.child[i].keys = node.child[i].keys[0:(t-1)]
        if not new_node.leaf:
            new_node.child = node.child[i].child[t:(2*t)]
            node.child[i].child = node.child[i].child[0:(t-1)]

    def inorder_traversal(self):
        self._inorder_traversal(self.root)

    def _inorder_traversal(self, node):
        n = len(node.keys)
        if node.leaf:
            for i in range(n):
                print(node.keys[i], end=' ')
        else:
            for i in range(n):
                self._inorder_traversal(node.child[i])
                print(node.keys[i], end=' ')
            self._inorder_traversal(node.child[n])

A = [21,14,2,11,7,20,13,30,18,5,6,29,12,27,4,28,10,15,22,1,19,3]
btree = BTree(5)
for value in A:
    btree.insert(value)

btree.inorder_traversal()